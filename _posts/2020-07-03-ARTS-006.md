---
layout: post
title:  "ARTS-006"
date:   2020-07-03 16:00:00 +0800
categories: ARTS
tags: leetcode
excerpt: python 
---

* content
{:toc}

# 一、Algorithm

## 斐波那契数列/台阶问题  
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。


```python
# lambda
fib = lambda n: 1 if n <= 2 else fib(n - 1) + fib(n - 2)

# 装饰器记忆法
def memo(func): 
    cache={}    
    def wrap(*args): 
        if args not in cache: 
            cache[args]=func(*args) 
        return cache[args] 
    return wrap 

@memo 
def fib(i): 
    if i<2: 
        return 1 
    return fib(i-1)+fib(i-2)

# 数学运算
def fib(n):
    a, b = 0, 1
    while a < n:
        a, b  = b, a + b
    print a
fib(1000)
```

## 链表反转 
[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/submissions/)
1->2->3->4转换成2->1->4->3
解题可参照[206. 反转链表（Python）](https://www.jianshu.com/p/e2ef8d4a60e3)、[链表反转的python多种方法实现](https://blog.csdn.net/weixin_39561100/article/details/79818949)
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None


a = Node("8")
b = Node("5")
c = Node("3")
d = Node("1")
d.next = c
c.next = b
b.next = a


def reverse_linked_node1(n: Node):
    if n is None or n.next is None:
        return n
    previous = None
    while n:
        next_node = n.next

        n.next = previous
        previous = n
        n = next_node
    return previous


def reverse_linked_node2(head: Node):
    if not head or not head.next:
        return head

    previous = None

    while head:
        cur = head
        head = head.next
        cur.next = previous
        previous = cur
    return previous


def reverse_linked_node3(head: Node):
    if not head or not head.next:
        return head

    p = reverse_linked_node3(head.next)
    head.next.next = head
    head.next = None
    return p



def print_node(node: Node):
    while node:
        print(f"{node.val} =>", end=" ")
        node = node.next
    print()


a = Node("8")
b = Node("5")
c = Node("3")
d = Node("1")
d.next = c
c.next = b
b.next = a

print_node(d)
print_node(reverse_linked_node1(d))

a = Node("8")
b = Node("5")
c = Node("3")
d = Node("1")
d.next = c
c.next = b
b.next = a

print_node(reverse_linked_node2(d))
a = Node("8")
b = Node("5")
c = Node("3")
d = Node("1")
d.next = c
c.next = b
b.next = a

print_node(reverse_linked_node3(d))
```
# 二、Review
[PEP 3107 -- Function Annotations](https://www.python.org/dev/peps/pep-3107/)
>用 : 类型的形式指定函数的参数类型，用 -> 类型 的形式指定函数的返回值类型。Python 解释器并不会因为这些注解而提供额外的校验，没有任何的类型检查工作。也就是说，这些类型注解加不加，对你的代码来说没有任何影响。但是出现以下这种代码时：
注意：注解中表达式会执行

```python
def contract(a: int, b: int = 2) -> str:
    return str(a) + str(b)


print(contract("a"))
# a2
```

# 三、Tip

## 装饰器：带参与多重
```python
# 函数带参
def tips(func):
    def wrapper(a, b):
        print("start")
        func(a, b)
        print("stop")

    return wrapper


@tips
def add(a, b):
    print("result:%s" % (a + b))

# 装饰器和函数都带参
def new_tips(param):
    def tips(func):
        def wrapper(a, b):
            print("start %s %s" %( param, func.__name__))
            func(a, b)
            print("stop %s %s" %( param, func.__name__))

        return wrapper

    return tips


@new_tips("sub")
def sub_name(a, b):
    print("result:%s" % (a - b))


add(1, 2)
sub_name(1, 2)


# 多重装饰器
def wrapper1(func):
    print("start ---111")
    def inner1():
        print('wrapper1 ,before func')
        ret = func()
        print('wrapper1 ,after func')
        return ret

    print('before return 1')
    return inner1
def wrapper3(func):
    print("start ---333")
    def inner3():
        print('wrapper3 ,before func')
        ret = func()
        print('wrapper3 ,after func')
        return ret
    print('before return 3')

    return inner3

def wrapper2(func):
    print("start ---222")
    def inner2():
        print('wrapper2 ,before func')
        ret = func()
        print('wrapper2 ,after func')
        return ret
    print('before return 2')

    return inner2

@wrapper3
@wrapper2
@wrapper1
def f():
    print('in f')
    return "final"

print("start")
temp = f()
print(temp)


```

## 随机
```python
import random
a = random.randint(1,5)
print(a)
print(random.choice(["aa", "bb", "cc"]))

```

## 多线程
```python
# 1
def my_thread(arg1, arg2):
    print(current_thread().getName(), ' start')
    print("%s : %s" % (arg1, arg2))
    time.sleep(1)
    print(current_thread().getName(), ' finish')


for i in range(1, 6):
    # t1 = my_thread(i, i+1)
    t1 = threading.Thread(target=my_thread, args=(i, i + 1))
    t1.start()

# 2
class MyThread(threading.Thread):
    def run(self):
        print(current_thread().getName(), 'start')
        print('run')
        print(current_thread().getName(), 'stop')


t1 = MyThread()
t1.start()
t1.join()
```

## with
```python
class Testwith():
    def __init__(self):
        print("init")

    def __enter__(self):  # 类开始时，初始化后执行
        print("run")

    def __exit__(self, exc_type, exc_val, exc_tb):  # 类结束时运行
        if exc_tb is None:
            print('正常结束')
        else:
            print("has error %s" % exc_tb)
        print("exit")


with Testwith():
    print("test is running")
    raise NameError("test name error")
```
# 四、Share
> 缺陷预防只是测试价值的一个分支，今后测试价值的发展会是多样化的。
> 测试必须实现的价值  vs 测试可以实现的价值