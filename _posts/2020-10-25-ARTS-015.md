---
layout: post
title:  "ARTS-015"
date:   2020-10-25 11:00:00 +0800
categories: ARTS
tags: python 算法
excerpt: leetcode
---

* content
{:toc}

# 一、Algorithm
## 88. 合并两个有序数组
https://leetcode-cn.com/problems/merge-sorted-array/
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

 

说明：

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。


示例：

输入：
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出：[1,2,2,3,5,6]


提示：

-10^9 <= nums1[i], nums2[i] <= 10^9
nums1.length == m + n
nums2.length == n
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1_copy = nums1[:m]
        nums1[:] = []
        p1 = p2 = 0
        while p1 < m and p2 < n:
            if nums1_copy[p1] <= nums2[p2]:
                nums1.append(nums1_copy[p1])
                p1 += 1
                continue
            else:
                nums1.append(nums2[p2])
                p2 += 1
                continue

        nums1.extend(nums1_copy[p1:])
        nums1.extend(nums2[p2:])
```
## 101. 对称二叉树
给定一个二叉树，检查它是否是镜像对称的。

 

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3


但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3


进阶：

你可以运用递归和迭代两种方法解决这个问题吗？

```python
    # Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:

        # 1、递归
        # def is_mirror(root1, root2):
        #     if root1 is None and root2 is None:
        #         return True
        #     if root1 is None and root2 is not None:
        #         return False
        #     if root1 is not None and root2 is None:
        #         return False
        #     return root1.val == root2.val  and is_mirror(root1.left, root2.right)  and  is_mirror(root1.right, root2.left)
        
        # return is_mirror(root, root)

        # 2、迭代
        check_list = [root, root]
        while check_list:
            node1 = check_list.pop()
            node2 = check_list.pop()
            if node1 is None and node2 is None:
                continue
            if node1.val != node2.val:
                return False
            
            if node1.left and node2.right:
                check_list.append(node1.left)
                check_list.append(node2.right)

            if node1.right and node2.left:
                check_list.append(node1.right)
                check_list.append(node2.left)

            if node1.left and node2.right is None:
                return False
            elif node1.right and node2.left is None:
                return False
            elif node1.left is None and node2.right:
                return False
            elif node1.right is None and node2.left:
                return False
        return True

        # 3、正反向先序遍历，比较列表
        # if not root:
        #     return True
        # pre_list = []
        # after_list = []
        # def pre_order(root):
        #     pre_list.append(root.val)
        #     if root.left:
        #         pre_order(root.left)
        #     else:
        #         pre_list.append(-1)
        #     if root.right:
        #         pre_order(root.right)
        #     else:
        #         pre_list.append(-1)
            
        # def after_order(root):
        #     after_list.append(root.val)
        #     if root.right:
        #         after_order(root.right)
        #     else:
        #         after_list.append(-1)
        #     if root.left:
        #         after_order(root.left)
        #     else:
        #         after_list.append(-1)
        
        # pre_order(root)
        # after_order(root)
        # if pre_list == after_list:
        #     return True
        # else:
        #     return False
```
## 121. 买卖股票的最佳时机
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #暴力法 O(n^2)
        # max_profit = 0
        # for i in range(len(prices) - 1):
        #     for j in range(i + 1, len(prices)):
        #         if prices[j] > prices[i]:
        #             max_profit = max(max_profit, prices[j] - prices[i])
        # return max_profit
        
        # 差值法 O(n)
        min_price = max(prices)
        max_profit = 0
        for i in prices:
            if i < min_price:
                min_price = i
            elif i - min_price > max_profit:
                max_profit = i - min_price
        return max_profit
```
## 122. 买卖股票的最佳时机 II
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        # 假设每天都买入卖出，所有上涨（正值）都是盈利
        result = 0
        if not prices:
            return result
        for n in range(len(prices) - 1):
            if prices[n + 1] - prices[n] > 0:
                result += (prices[n + 1] - prices[n] )
        return result
        
        # 笨方法
        # if len(prices) <= 1:
        #     return 0
        # profit_list = []
        # start = pre = None
        # for price in prices:
        #     if start is None:
        #         start = price
        #         pre = price
        #         continue
        #     if price < pre:
        #         if pre == start:
        #             start = price
        #             pre = price
        #         else:
        #             profit_list.append(pre - start)
        #             start = price
        #             pre = price
        #     else:
        #         pre = price
        # else:
        #     if prices[-1] > start:
        #         profit_list.append(prices[-1] - start)
        # return sum(profit_list)
```
## 141. 环形链表
https://leetcode-cn.com/problems/linked-list-cycle/
给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

 

进阶：

你能用 O(1)（即，常量）内存解决此问题吗？

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：false
解释：链表中没有环。


提示：

链表中节点的数目范围是 [0, 104]
-105 <= Node.val <= 105
pos 为 -1 或者链表中的一个 有效索引 。
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        # 队列查询法
        # result = []
        # while head:
        #     if head not in result:
        #         result.append(head)
        #         head = head.next
        #     else:
        #         return True
        # else:
        #     return False

        # 快慢指针：存在循环则必然相遇
        if not head or not head.next:
                return False
            
            slow = head
            fast = head.next

            while slow != fast:
                if not fast or not fast.next:
                    return False
                slow = slow.next
                fast = fast.next.next
            
            return True

```

## 142. 环形链表 II
https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

进阶：

你是否可以使用 O(1) 空间解决此题？


示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。


提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        result = []
        while head:
            if head not in result:
                result.append(head)
                head = head.next
            else:
                return head
        return None
```
## 155. 最小栈
https://leetcode-cn.com/problems/min-stack/
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。


示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.


提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min = None


    def push(self, x: int) -> None:
        self.stack.append(x)
        if self.min is None or x < self.min :
            self.min = x 

    def pop(self) -> None:
        self.stack.pop()
        self.min = min(self.stack) if self.stack else None

    def top(self) -> int:
        return self.stack[-1] if self.stack else None

    def getMin(self) -> int:
        return self.min
```
## 198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

0 <= nums.length <= 100
0 <= nums[i] <= 400
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # dp
        size = len(nums)
        if size == 0:
            return 0
        if size == 1:
            return nums[0]

        max_profits = [0] * size
        max_profits[0] = nums[0]
        max_profits[1] = max(nums[0], nums[1])
        for i in range(2,size):
            max_profits[i] = max(max_profits[i-1], max_profits[i-2] + nums[i])
        return max_profits[size -1 ]
```
## 217. 存在重复元素
https://leetcode-cn.com/problems/contains-duplicate/
给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

 

示例 1:

输入: [1,2,3,1]
输出: true
示例 2:

输入: [1,2,3,4]
输出: false
示例 3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)
```
## 226. 翻转二叉树
翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:

        # 递归（反转左右节点，递归其子节点）
        if not root:
            return None
        
        root.left , root.right  = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)
        return root

        # 蛮力法： 层级遍历二叉树，记录进列表； 新建一个二叉树根据列表进行还原
        # if root is None:
        #     return None
        # result_list = []
        # start = root
        # temp_list = [start]
        # while temp_list:
        #     node = temp_list.pop(0)
        #     result_list.append(node)
        #     if node is None:
        #         continue
        #     temp_list.append(node.left)
        #     temp_list.append(node.right)
        # new_start = result_list.pop(0)
        # temp_list2=[new_start]

        # while result_list:
        #     temp = temp_list2.pop(0)
        #     node_right = result_list.pop(0)
        #     if node_right:
        #         temp.right = node_right
        #         temp_list2.append(node_right)
        #     else:
        #         temp.right = None

        #     node_left = result_list.pop(0)
        #     if node_left:
        #         temp.left = node_left
        #         temp_list2.append(node_left)
        #     else:
        #         temp.left = None
        # return new_start
```
## 231. 2的幂
https://leetcode-cn.com/problems/power-of-two/
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例 1:

输入: 1
输出: true
解释: 20 = 1
示例 2:

输入: 16
输出: true
解释: 24 = 16
示例 3:

输入: 218
输出: false

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        while n // 2  != 0:
            if n % 2 == 1:
                return False
            n = n// 2
        return True
```
## 234. 回文链表
请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        # 时间O(n), 空间O(n)
        # result = []
        # while head:
        #     result.append(head.val)
        #     head = head.next
        # return result == result[::-1]

        # 时间O(n),空间O(1)
        # 通过快慢指针获取中间节点，然后反转中间节点之后的链表，再双向指针比对，最后再还原后半部分链表
        if not head:
            return True

        def get_half_node(head):
            fast = slow = head
            while fast.next and fast.next.next:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def reverse_link(head):
            previous = None
            current = head
            while current:
                next_node = current.next
                current.next = previous
                previous = current
                current = next_node
            return previous


        start = head
        half_node  = get_half_node(head)
        start_of_reversed_link = reverse_link(half_node.next)
        end = start_of_reversed_link

        result = True
        while result and end is not None:
            if start.val != end.val:
                return False
            start = start.next
            end = end.next
        half_node.next = reverse_link(start_of_reversed_link)
        return result


```

## 235. 二叉搜索树的最近公共祖先
https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]



 

示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。


说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        # 二次遍历对比路径
        # def _get_path(root, node):
        #     path = []
        #     while root !=node:
        #         if node.val > root.val:
        #             path.append(root)
        #             root = root.right
        #         elif node.val < root.val:
        #             path.append(root)
        #             root = root.left
        #     path.append(root)

        #     return path

        # start1 = start2 = root
        # path_p = _get_path(start1, p)
        # path_q = _get_path(start2, q)

        # result = None
        # for i in zip(path_p,path_q):
        #     if i[0] == i[1]:
        #         result = i[0]
        #     else:
        #         break
        # return result

        # 递归
        ancestor = root
        if p.val< ancestor.val and q.val < ancestor.val:
            return self.lowestCommonAncestor(ancestor.left,p,q)
        
        if p.val > ancestor.val and q.val > ancestor.val:
            return self.lowestCommonAncestor(ancestor.right,p ,q)
        return ancestor

```
## 237. 删除链表中的节点
https://leetcode-cn.com/problems/delete-node-in-a-linked-list/
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。

 

现有一个链表 -- head = [4,5,1,9]，它可以表示为:



 

示例 1：

输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2：

输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.


提示：

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        # 固定思维限制了我。。。。
        node.val = node.next.val
        node.next = node.next.next

```
## 292. Nim 游戏
https://leetcode-cn.com/problems/nim-game/
你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合，你作为先手。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
j假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

示例 1：

输入：n = 4
输出：false 
解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
示例 2：

输入：n = 1
输出：true
示例 3：

输入：n = 2
输出：true

提示：
1 <= n <= 231 - 1

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        # 大家都是聪明人，智商题
        return n % 4 != 0
```
## 344. 反转字符串
https://leetcode-cn.com/problems/reverse-string/
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

 

示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        s[:] = s[::-1]
```
## 365. 有多少小于当前数字的数字
https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/

给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。

以数组形式返回答案。

 

示例 1：

输入：nums = [8,1,2,2,3]
输出：[4,0,1,1,3]
解释： 
对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
对于 nums[1]=1 不存在比它小的数字。
对于 nums[2]=2 存在一个比它小的数字：（1）。 
对于 nums[3]=2 存在一个比它小的数字：（1）。 
对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
示例 2：

输入：nums = [6,5,4,8]
输出：[2,1,0,3]
示例 3：

输入：nums = [7,7,7,7]
输出：[0,0,0,0]


提示：

2 <= nums.length <= 500
0 <= nums[i] <= 100
```python
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
		"""暴力法"""
        # result = [0] * len(nums)
        # for i in range(len(nums)):
        #     count = 0
        #     for num in nums:
        #         if nums[i] > num:
        #             count += 1
        #     result[i] = count
        # return result
        """计数法"""
        nums_counts = [0] * 101
        for i in nums:
            nums_counts[i] += 1
        temp = 0
        for j in range(len(nums_counts)):
            temp, nums_counts[j] = temp + nums_counts[j], temp
        result = []
        for num in nums:
            result.append(nums_counts[num])
        return result

```

## 543. 二叉树的直径
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

 

注意：两结点之间的路径长度是以它们之间边的数目表示。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:

        self.max_diameter = 0
        def get_max_depth(root):
            if root is None:
                return 0
            L = get_max_depth(root.left)
            R = get_max_depth(root.right)
            if (L+R) >self.max_diameter:
                self.max_diameter = L+R
            return max(L , R)+ 1
        get_max_depth(root)
        return self.max_diameter

        # 获取深度 + 前序遍历， 想复杂了
        # if root is None:
        #     return 0
        # depth_list = []

        # def get_max_depth(root):
        #     if root is None:
        #         return -1
        #     if root.left is None and root.right is None:
        #         return 0
        #     return max(get_max_depth(root.left) + 1, get_max_depth(root.right) + 1)

        # def pre_order(root):
        #     depth_list.append(get_max_depth(root.left) + 2 + get_max_depth(root.right))
        #     if root.left:
        #         pre_order(root.left)
        #     if root.right:
        #         pre_order(root.right)

        # pre_order(root)
        # return max(depth_list)
```
## 557. 反转字符串中的单词 III
https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例：

输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"


提示：

在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join([sub[::-1] for sub in s.split()])
```





## LCP 01. 猜数字
https://leetcode-cn.com/problems/guess-numbers/
小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？

 

输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。

 

示例 1：

输入：guess = [1,2,3], answer = [1,2,3]
输出：3
解释：小A 每次都猜对了。


示例 2：

输入：guess = [2,2,3], answer = [3,2,1]
输出：1
解释：小A 只猜对了第二次。


限制：

guess的长度 = 3
answer的长度 = 3
guess的元素取值为 {1, 2, 3} 之一。
answer的元素取值为 {1, 2, 3} 之一。

```python
class Solution:
    def game(self, guess: List[int], answer: List[int]) -> int:
        count = 0
        for i in range(len(guess)):
            if guess[i] == answer[i]:
                count += 1
        return count
```




## LCP 02. 分式化简
https://leetcode-cn.com/problems/deep-dark-fraction/
有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？

连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。


输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。

示例 1：

输入：cont = [3, 2, 0, 2]
输出：[13, 4]
解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。
示例 2：

输入：cont = [0, 0, 3]
输出：[3, 1]
解释：如果答案是整数，令分母为1即可。
限制：

cont[i] >= 0
1 <= cont的长度 <= 10
cont最后一个元素不等于0
答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。

```python
class Solution:
    def fraction(self, cont: List[int]) -> List[int]:
        n = m = 0
        for i in cont[::-1]:
            if n == 0:
                n,m = i,1
                continue
            n,m = i * n + m ,  n
        """
        a + 1 / b 必定是最简分数，所以不用求GCD了。 
        （前提：a是整数，b是一个最简分数） 因为b是最简分数，所以 1 / b肯定也是一个最简分数，加上一个整数仍然是最简分数：（ab + 1）/ b 
        “”“
        # 数学是万能的
        # for i in range(n//2, 0, -1):
        #     if n % i ==0 and m % i == 0:
        #         return n //i, m// i
        
        return n,m
```
